#include "manevr.h"

#include <cmath>

double section(double startAngle, double currentAngle, bool omega) {
    double sect = startAngle - currentAngle;

    sect = (!omega && sect < 0) ? 2*GPI - sect : sect;
    sect = (omega && sect > 0) ? 2*GPI - sect : sect;

    return std::abs(sect);

}
double getManevrTime(double inAngle, double outAngle, double omega) {
    double sect = (section(inAngle, outAngle, omega > 0));
    return std::abs(sect / omega);
}
double getKurs(double psi, double sect, bool omega) {
    double kurs = (!omega) ? psi + sect : psi - sect;

    kurs = (kurs < 0) ? 2*GPI + kurs : kurs;
    kurs = (kurs > 2*GPI) ? kurs - 2*GPI : kurs;

    return kurs;
}
double getKursByAngle(double angle, double omega) {
    double kurs = (omega > 0) ? 2*GPI - angle : 2*GPI - angle -GPI ;
    if(kurs < 0) kurs = 2*GPI + kurs;
    return kurs;
}
double convertTo2PI(double angle) {
    //int k = std::floor(angle / 2*GPI);
    //angle -= 2*k*GPI;

    //angle = (angle >= 0) ? angle : 2*GPI - angle;
    double p2 = 2*GPI;
    while(angle >= p2) angle -= p2;
    while(angle < 0) angle += p2;

    return angle;
}
double fromCourceToxAxisAngle(double cource) {
    cource = 2*GPI - (cource - GPI2);
    return convertTo2PI(cource);
}
double fromxAxisAngleToCource(double angle) {
    angle = 2*GPI - angle + GPI2;
    return convertTo2PI(angle);
}

inline void pointInLocCoordSys(const coordinate& center, const coordinate& point, double& x21, double& y21, double& z21) {
    x21 = point.x - center.x,
    y21 = point.y - center.y,
    z21 = point.z - center.z;
}

InterceptionInfo interception(const LA& our, const LA& target) {
    double z21 = target.z - our.z, x21 = target.x - our.x; // ? ??????? ??????? ????????? (????? ??)
    double psi = angleBetweenPoints(Point2D(0, 0), Point2D(z21, x21));
    double fi2 = GPI2 + target.psi + psi;
    double v1 = our.v, v2 = target.v;

    double dist = distance(z21, x21, 0);				// ????????? ????????? ?? ????
    double fi	= asin((v2/v1) * sin(fi2))		;		// ???????????? ??? ???????
    double t = dist / (v1*cos(fi) + v2*cos(fi2));		// ??????????? ????? ?????? ?? ???? ? ?????? fi
    fi += psi;
    fi = GPI2 - fi;										// ???????????? ??? ??????? (????)

    bool possible = (t != NAN);
    return InterceptionInfo(possible, fi, t ,t*our.v);
}
InterceptionInfo interception_dl(const LA& our, const LA& target, double dl) {
    double z21 = target.z - our.z, x21 = target.x - our.x; // ? ??????? ??????? ????????? (????? ??)
    double psi = angleBetweenPoints(Point2D(0, 0), Point2D(z21, x21));
    double fi2 = GPI2 + target.psi + psi;
    double v1 = our.v, v2 = target.v;
    double dist = distance(z21, x21, 0);				// ????????? ????????? ?? ????

    double m = v1 / v2;
    double t = pow((m*dl + dist*cos(fi2)), 2) + (dist*dist -dl*dl)*(m*m - 1.0);
    t = sqrt(t) - (m*dl + dist*cos(fi2));
    t = t / (v2*(m*m - 1.0));

    double fi = asin( ( v2*t/(v1*t + dl) ) * sin(fi2) ) + psi;
    fi = fromxAxisAngleToCource(fi);

    bool possible = (t != NAN);
    return InterceptionInfo(possible, fi, t ,t*our.v);
}
PursuitInfo pursuit_dl(const LA& our, const LA& target, double dl) {
    double z21 = target.z - our.z, x21 = target.x - our.x; // ? ??????? ??????? ????????? (????? ??)
    double psi = angleBetweenPoints(Point2D(0, 0), Point2D(z21, x21));
    double fi2 = GPI2 + target.psi + psi;
    double v1 = our.v, v2 = target.v;
    double dist = distance(z21, x21, 0);				// ????????? ????????? ?? ????
    double m = v1 / v2;

    double t = dist * (m - cos(fi2)) - dl * (m - cos(fi2));
    t /= (v2*(m*m - 1.0));

    bool possible = (t != NAN);
    return PursuitInfo(possible, t, v1*t);
}

void subtask(const LA& our, const LA& target, LA& subour, LA& subtar) {
    double x21, y21, z21;
    pointInLocCoordSys(our, target, x21, y21, z21);

    double turn_angle = 2.0*GPI - our.psi;

    subour = our;
    subour.psi = 0.0;
    subour.x = subour.z = 0;

    subtar = target;
    subtar.psi = target.psi - our.psi;
    if(subtar.psi < 0) subtar.psi += 2.0*GPI;
    subtar.z = z21 * cos(turn_angle) + x21 * sin(turn_angle);
    subtar.x = x21 * cos(turn_angle) - z21 * sin(turn_angle);
}

void buildRadiusManevr(const LA& our, double gamma, double& z0, double& x0, double R) {
    R = our.v*our.v / (G*tan(gamma));
    R = std::abs(R);
    /* ????? ??????? ????????? */
    double fi1x = GPI2 - our.psi;				// ???? ???????????? ??? ???????
    double k = (-1) / (tan(fi1x));				// ??????????? ?????? ???????????????? ??????? ????????, (?? ???? ?????? ????? ??????????)
    double kg = atan(k);						// ???? ???????????? ??? ??????? ?????? y = kx
    double cz1 = R*cos(kg), cx1 = R*sin(kg);	// ?????????? ?????? ?????????? ???????
    // ???? ???? ?? 90 ?? 270 ?? ???????? ?????????? ?????? ??? ????????? ?? ???????, ?????? ?? ?? ?????? ???????
    if( !(our.psi > GPI2 && our.psi < 3*GPI2)) { cz1 = -cz1; cx1 = -cx1; }
    if(gamma > 0) { cz1 = -cz1; cx1 = -cx1; }		// ???? ????? ?? ???????, ?? ??????
    cz1 += our.z; cx1 += our.x;					// ????????? ????? ? ???????? ???????????? ????? ?? ??????????

    z0 = cz1, x0 = cx1;
}

int interception_maneuver(const LA& our, const LA& target, double dl, double gamma, ManeuverInfo& minfo, InterceptionInfo& info) {
    LA subour = our, subtar = target;
    subtask(our, target, subour, subtar);

    double x21, y21, z21, f21;
    pointInLocCoordSys(subour, subtar, x21, y21, z21);
    f21 = subtar.psi;

    double R = subour.v*subour.v / (G*tan(gamma));
    R = std::abs(R);
    /* ????? ??????? ????????? */
    double fi1x = GPI2 - our.psi;				// ???? ???????????? ??? ???????
    double k = (-1) / (tan(fi1x));				// ??????????? ?????? ???????????????? ??????? ????????, (?? ???? ?????? ????? ??????????)
    double kg = atan(k);						// ???? ???????????? ??? ??????? ?????? y = kx
    double cz1 = R*cos(kg), cx1 = R*sin(kg);	// ?????????? ?????? ?????????? ???????
    // ???? ???? ?? 90 ?? 270 ?? ???????? ?????????? ?????? ??? ????????? ?? ???????, ?????? ?? ?? ?????? ???????
    if( !(our.psi > GPI2 && our.psi < 3*GPI2)) { cz1 = -cz1; cx1 = -cx1; }
    if(gamma > 0) { cz1 = -cz1; cx1 = -cx1; }		// ???? ????? ?? ???????, ?? ??????
    cz1 += our.z; cx1 += our.x;					// ????????? ????? ? ???????? ???????????? ????? ?? ??????????

    auto f = [&](double alpha) {
        double a1 = subtar.v / subour.v;
        double r, z0, x0;
        buildRadiusManevr(subour, gamma, z0, x0, r);
        LA our2;
        if(gamma < 0) our2 = LA(0.0, x0 + R*sin(alpha), 0.0, z0 + R*cos(alpha), subour.v);
        else our2 = LA(0.0, x0 + R*sin(GPI - alpha), 0.0, z0 + R*cos(GPI - alpha), subour.v);
        LA tar2(0.0, x21 + a1*alpha*R*sin(GPI2 - f21), y21, z21+a1*alpha*cos(GPI2 - f21), subtar.v);
        tar2.psi = subtar.psi;

        double cource = interception_dl(our2, tar2, dl).getCource();
        double manevr_cource = (gamma > 0) ? alpha : (2.0*GPI - alpha);
        return manevr_cource - cource;

    };

    double alpha = 0.0, prev = 0.0, a = 0.0, b = 2.0*GPI;
    double eps = 0.0001;

    size_t index = 0;
   do {
        prev = alpha;
        double f_prev = f(prev), f_a = f(a), f_b = f(b);
        alpha = prev - (f_prev / (f_b - f_prev)) * (b - prev);
    } while(std::abs(prev - alpha) > eps && index++ < 50);

    if(index >= 50) {
        info.possible = false;
        return index;
    }

    // ???? ????? ? ?????? ? ????????
    double in1 = angleBetweenPoints(Point2D(cz1, cx1), Point2D(our.z, our.x));
    double out1 = (gamma < 0) ? in1 + alpha : in1 - alpha;
    convertTo2PI(out1);				// ???? ????? ?? 0...2PI
    // ??????? ???????? ? ?????
    double omega1 = our.v / R;
    if(gamma > 0) omega1 = -omega1;
    double time1 = getManevrTime(in1, out1, omega1);	// ??????? ?????????? ??????? ?? ???????? ?? alpha1


    minfo = ManeuverInfo(coordinate(cx1, our.y, cz1), R, time1, in1, out1, omega1);

    double a1 = target.v / our.v;
    LA our2(time1, cx1 + R*sin(out1), 0.0, cz1 + R*cos(out1), our.v);
    LA tar2 = target;
    tar2.x += time1*tar2.v*sin(GPI2 - tar2.psi);
    tar2.z += time1*tar2.v*cos(GPI2 - tar2.psi);
    info = interception_dl(our2, tar2, dl);

    return index;
}


/* ????? ?????? */

void tranverseInputInfo(const LA& our, const LA& target, double& B, double& P, double& v1, double& v2, double& g0, int& change_m) {


    double gtarget = fromCourceToxAxisAngle(target.psi);	// ???? ???????????? ??? ???????
    double gour	   = fromCourceToxAxisAngle(our.psi);

    P = (our.z - target.z)*cos(gtarget) + (our.x - target.x)*sin(gtarget);
    B = (our.z - target.z)*sin(gtarget) - (our.x - target.x)*cos(gtarget);

    B /= 1000; P /= 1000;

    g0 = (gour - gtarget);


    if(g0 < 0) g0 += 2*GPI;
    if(B < 0) {
        change_m = -change_m;
        B = -B;
        g0 = 2*GPI - g0;
    }

    //g0 = convertTo2PI(g0); // ??????? ???

    v1 = our.v / 1000.0; v2 = target.v / 1000.0;
}
double findFirstGamma(double b, double p, double fip, double dl, double a1) {
    double e  = -b + dl*sin(fip);
    double d2 = -p - dl*cos(fip);
    double s  = a1*(b - dl*sin(fip));

    double a = e*e + d2*d2;
    double b2 = 2.0*s*e;
    double c = s*s - d2*d2;

    double x;
    if(p >= 0) x = (-b2 - sqrt(b2*b2 - 4*a*c)) / (2.0*a);
    else x = x = (-b2 + sqrt(b2*b2 - 4*a*c)) / (2.0*a);

    double gamma0 = acos(x);

    return gamma0;
}

TwoManeuverInfo buildInfoForTwoManeuverTrack(const LA& our, const LA& target, double R, double alpha1, double alpha2, double C, double kurs, int m1, int m2, bool change_center);
void tranverseOutputInfo(long double& g1, long double& R, long double& C, double psi2);

TwoManeuverInfo twoManeuver2(const LA& our, const LA& target, double gamma1, double gamma2, double q_zad, double dl) {

    double B, P, v1, v2, g0;
    int change_m = 1;
    tranverseInputInfo(our, target, B, P, v1, v2, g0, change_m);


    /* ???????? ?????? */
    long double p = q_zad;
    long double sk = dl/1000.0, vk = v1;
    int m1 = sign(gamma1), m2 = sign(gamma2);
    long double Rp = std::abs( (our.v*our.v) / (1000*G*tan(gamma1)) ), Rmin = std::abs( (our.v*our.v) / (1000*G*tan(30*d2r)) );
    long double r1 = Rp, r2 = Rp;

    m1 *= change_m; m2 *= change_m;

    /* ?????????????? ?????????? */
    long double a1 = v2 / v1,
            a2 = (2*v2) / (v1 + vk);

    /* ??? ?????? ???????? */
    long double cg = findFirstGamma(B, P, p, sk, a1);
    long double deltaR = 2.5;

    /* ?????? ????????? */
    r1 = r2 = deltaR;

    /* ?????????? ????????????? */
    const long double de_dr	= a1*(m2 - m1) - m1*cos(g0) + m2*cos(p);
    const long double dd1_dr	= -m1*a1 + m2*a2;
    const long double ds_dr = a1*(m1*cos(g0) - m2*cos(p)) - m2 + m1;

    /* ?????????? ???????? */
    long double g1,					// ???? ?? ????????????? ???????
                R_g1 = 0,			// ?????? ??????????
                C = 0,				// ????? ?????????????? ???????
                L,					// ???? ?????????? ?????? ?? ????? ?????????
                alpha1,				// ???????? ??????? ????????? (? ????????? ???????)
                alpha2;				// ???????? ??????? ????????? (? ????????? ???????)

    size_t iter_count(0);
    while(R_g1 < Rp && C >= 0 && iter_count++ < 50) {

        /* ????? ??? ? ???????? */
        long double i = (cg - g0 >= 0) ? 0 : 1;
        long double j = (p-cg >= 0) ? 0: 1;

        /* ???????? */
        long double e	= (m2*r2 - m1*r1)*a1 - B + sk*sin(p) - m1*r1*cos(g0) + m2*r2*cos(p);
        long double d1	= a2*m2*r2 - a1*m1*r1;
        long double d2	= -P -sk*cos(p) + m2*r2*sin(p) - m1*r1*sin(g0) +
                        a1*(GPI + (GPI + g0 - 2*GPI*i)*m1)*r1 +
                        a2*(GPI + (GPI - p - 2*GPI*j)*m2)*r2;
        long double s	= (B - sk*sin(p) + m1*r1*cos(g0) - m2*r2*cos(p))*a1 - m2*r2 + m1*r1;

        /* ????????????? */
        long double dd2_dr = m2*sin(p) - m1*sin(g0) + a1*(GPI + (GPI + g0 -2.0*GPI*i)*m1) + a2*(GPI + (GPI - p - 2.0*GPI*j)*m2);

        long double dcg_dr = (de_dr*cos(cg) + (dd1_dr*cg + dd2_dr)*sin(cg) + ds_dr) / ((e-d1)*sin(cg) - (d1*cg + d2)*cos(cg));

        /* ?????????? */
        cg += dcg_dr*deltaR;

        /* ?????? */
        long double R_cg = ( (P+sk*cos(p))*sin(cg) + (B - sk*sin(p))*(cos(cg) -a1 ) ) / (de_dr*cos(cg) + (dd1_dr*cg + dd2_dr)*sin(cg) + ds_dr);

        if(R_cg >= Rp || C < 0) break;

        // ?????????? ????? ????????
        g1 = cg;
        R_g1 = R_cg;
        C		= (B - sk*sin(p) + m1*r1*cos(g0) - m2*r2*cos(p) + (m2*r2 - m1*r1)*cos(cg)) / sin(cg);

        /* ?????? ??????????? */
        long double delta_cg1 = cg - g0 + 2.0*GPI*i;
        alpha1 = GPI + (GPI - delta_cg1)*m1;

        long double delta_cg2 = p - cg + 2.0*GPI*j;
        alpha2 = GPI + (GPI - delta_cg2)*m2;

        L       = a1*alpha1*r1 + a2*alpha2*r2 + a1*C;

        // ?????????? ?? ???????? ?????????? ??? ????????? ????????
        r1 += deltaR;
        r2 += deltaR;

    }

    // ? ??????? ???
    tranverseOutputInfo(g1, R_g1, C, target.psi);
    //g1 = fromxAxisAngleToCource(g1);

    m1 *= change_m; m2 *= change_m;
    return buildInfoForTwoManeuverTrack(our, target, R_g1, alpha1, alpha2, C, g1, m1, m2, change_m<0);
}
void tranverseOutputInfo(long double& g1, long double& R, long double& C, double psi2) {
    R *= 1000; // ? ?????
    C *= 1000;
    C = std::abs(C);
    double gtarget = fromCourceToxAxisAngle(psi2);	// ???? ???????????? ??? ???????
    g1 = g1 + gtarget;
    g1 = fromxAxisAngleToCource(g1);
}
TwoManeuverInfo buildInfoForTwoManeuverTrack(const LA& our, const LA& target, double R, double alpha1, double alpha2, double C, double kurs, int m1, int m2, bool change_center) {
    /* ????? ??????? ????????? */
    double fi1x = GPI2 - our.psi;				// ???? ???????????? ??? ???????
    double k = (-1) / (tan(fi1x));				// ??????????? ?????? ???????????????? ??????? ????????, (?? ???? ?????? ????? ??????????)
    double kg = atan(k);						// ???? ???????????? ??? ??????? ?????? y = kx
    double cz1 = R*cos(kg), cx1 = R*sin(kg);	// ?????????? ?????? ?????????? ???????
    // ???? ???? ?? 90 ?? 270 ?? ???????? ?????????? ?????? ??? ????????? ?? ???????, ?????? ?? ?? ?????? ???????
    if( !(our.psi > GPI2 && our.psi < 3*GPI2)) { cz1 = -cz1; cx1 = -cx1; }
    if(m1 > 0) { cz1 = -cz1; cx1 = -cx1; }		// ???? ????? ?? ???????, ?? ??????
    cz1 += our.z; cx1 += our.x;					// ????????? ????? ? ???????? ???????????? ????? ?? ??????????

    // ???? ????? ? ?????? ? ????????
    double in1 = angleBetweenPoints(Point2D(cz1, cx1), Point2D(our.z, our.x));
    double out1 = (m1 < 0) ? in1 + alpha1 : in1 - alpha1;
    convertTo2PI(out1);				// ???? ????? ?? 0...2PI
    // ??????? ???????? ? ?????
    double gm1 = atan((our.v*our.v) / (G*R));
    double omega1 = our.v / R;
    if(m1 > 0) omega1 = -omega1;
    double time1 = getManevrTime(in1, out1, omega1);	// ??????? ?????????? ??????? ?? ???????? ?? alpha1

    ManeuverInfo minfo1(coordinate(cx1, our.y, cz1), R, time1, in1, out1, omega1);

    // ?????????? ?????? ?? ??????? ?????????
    double z1end = cz1 + R*cos(out1), x1end = cx1 + R*sin(out1);
    double kurs_out = getKursByAngle(out1, omega1);			// ???? ?? ?????? ?? ??????? ?????????

    // ?????????? ????? ?? ?????? ????????
    double fig1 = fromCourceToxAxisAngle(kurs_out);					// ???? ???????????? ??? Ox
    double z2in = z1end + C*cos(fig1), x2in = x1end + C*sin(fig1);


    /* ????? ??????? ????????? */
    double fi2x = GPI2 - kurs_out;									// ???? ???????????? ??? ???????
    double k2 = (-1) / (tan(fi2x));								// ??????????? ?????? ???????????????? ??????? ????????, (?? ???? ?????? ????? ??????????)
    double kg2 = atan(k2);										// ???? ???????????? ??? ??????? ?????? y = kx
    double cz2 = R*cos(kg2), cx2 = R*sin(kg2);	// ?????????? ?????? ?????????? ??????? (???? ?????)
    if( !(kurs_out > GPI2 && kurs_out < 3*GPI2) ) { cz2 = -cz2; cx2 = -cx2; }
    if(m2 > 0) { cz2 = -cz2; cx2 = -cx2; }

    cz2 += z2in; cx2 += x2in;

    // ???? ????? ? ?????? ?? ?????? ????????
    double in2 = angleBetweenPoints(Point2D(cz2, cx2), Point2D(z2in, x2in));
    double out2 = (m2 < 0) ? in2 + alpha2 : in2 - alpha2;
    convertTo2PI(out2);
    // ??????? ???????? ? ?????
    double gm2 = atan((our.v*our.v) / (G*R));
    double omega2 = our.v / R;
    if(m2 > 0) omega2 = -omega2;
    double time2 = getManevrTime(in2, out2, omega2);

    ManeuverInfo minfo2(coordinate(cx2, our.y, cz2), R, time2, in2, out2, omega2);

    // ????? ?????
    double time = time1 + C/our.v + time2;

    return TwoManeuverInfo(minfo1, kurs_out, C, minfo2, -1, time, (time > 0 && R > 0));
}


TwoManeuverInfo optimal_manevr(const LA& our, const LA& target, double gamma1, double gamma2, double q_zad, double dl) {
    double gm1 = std::abs(gamma1), gm2 = std::abs(gamma2);

    TwoManeuverInfo variables[4];
    variables[0] = twoManeuver2(our, target, gm1, gm2, q_zad, dl);
    variables[1] = twoManeuver2(our, target, gm1, -gm2, q_zad, dl);
    variables[2] = twoManeuver2(our, target, -gm1, gm2, q_zad, dl);
    variables[3] = twoManeuver2(our, target, -gm1, -gm2, q_zad, dl);

    TwoManeuverInfo* best_variable = &variables[0];
    for(int i = 1; i < 4; ++i)
        if(variables[i].time < best_variable->time)
            best_variable = &variables[i];

    return *best_variable;
}


/* ?????????? ???????? */

ManeuverInfo buildManevr( double v1, double fi1, double v2, double fi2, double gamma, coordinate p1, coordinate p2) {
    double R = v1*v1 / (G*tan(gamma));					// ?????? ??????
    double fi1x = GPI2 - fi1,  fi2x = GPI2 - fi2;		// ???? ???????????? ??? ???????
    double k = (-1) / (tan(fi1x));						// ??????????? ?????? ???????????????? ??????? ????????, (?? ???? ?????? ????? ??????????)
    double kg = atan(k);								// ???? ???????????? ??? ??????? ?????? y = kx

    // ?????????? ?????? ?????????? ??????? R (+/-)
    double z0 = -R*cos(kg), x0 = -R*sin(kg);

    double t_full = 0.64 * v1 / tan(gamma);				// ????? ??????? ??????
    double turningAngle = angleBetweenPoints(Point2D(0, 0), Point2D(z0,  x0)),
           startSsection = GPI - turningAngle;

    double min = 2*GPI, minAngle = 0;
    for(double angle = 0.0; angle < 2*GPI; angle += GPI/180.0) {
        // ?????? ???? ? ??????? ? ????????? ????? ?? ??????????
        double section = abs(startSsection + angle);
        double need_time = (abs(section - 2*GPI))*R/v1;

        // ?????? ????? ?? ???????????
        double zCircle = z0 + R*cos(angle), xCircle = x0 + R*sin(angle);
        double zTarget = p2.z + need_time*v2*cos(fi2x), xTarget = p2.x + need_time*v2*sin(fi2x);

        // ?????? ?????? ? ????????? ??????????
        LA our, target;
        our.z = zCircle, our.x = xCircle, our.v = v1, our.psi = fi1;
        target.z = zTarget, target.x = xTarget, target.v = v2, target.psi = fi2;

        InterceptionInfo inf = interception_dl(our, target, 1000);

        double kurs = GPI - angle;
        if(abs(inf.getCource() - kurs) < min) {
            min = abs(inf.getCource() - kurs);
            minAngle= angle;
        }
    }

    double omega = v1 / R;												// ??????? ???????? ???????? (!!! ????? ?????????? ???????????)
    double startAngle = angleBetweenPoints(Point2D(0, 0), Point2D(-z0,  -x0));
    double section = startAngle - minAngle;								// ???? 2PI - ??????? ?? ???????????
    double need_time = section*R/v1;
    //coordinate outPoint(x0+R*sin(minAngle), p1.y, z0+R*cos(minAngle));
    return ManeuverInfo(coordinate(x0, p1.y, z0), R, need_time, startAngle, minAngle, -omega);
}
inline void angInc(double& angle, double delt) {
    angle += delt;
    angle = (angle >= 2*GPI) ? (angle-2*GPI) : angle;
    angle = (angle < 0.0)	 ? 2*GPI + angle : angle;
}



// ?????? ?????????? ??? ???????
ManeuverInfo buildManevrInfo(const LA& pos, double fi2, double gamma) {
    double R = pos.v*pos.v / (G*tan(gamma));			// ?????? ??????
    /* ????? ??????? ????????? */
    double fi1x = GPI2 - pos.psi;				// ???? ???????????? ??? ???????
    double k = (-1) / (tan(fi1x));				// ??????????? ?????? ???????????????? ??????? ????????, (?? ???? ?????? ????? ??????????)
    double kg = atan(k);						// ???? ???????????? ??? ??????? ?????? y = kx
    double cz1 = R*cos(kg), cx1 = R*sin(kg);	// ?????????? ?????? ?????????? ???????
    // ???? ???? ?? 90 ?? 270 ?? ???????? ?????????? ?????? ??? ????????? ?? ???????, ?????? ?? ?? ?????? ???????
    if( !(pos.psi > GPI2 && pos.psi < 3*GPI2)) { cz1 = -cz1; cx1 = -cx1; }
    if(gamma > 0) { cz1 = -cz1; cx1 = -cx1; }		// ???? ????? ?? ???????, ?? ??????
    cz1 += pos.z; cx1 += pos.x;					// ????????? ????? ? ???????? ???????????? ????? ?? ??????????

    double omega1 = pos.v / R;
    double alpha1 = section(pos.psi, fi2, omega1);
    // ???? ????? ? ?????? ? ????????
    double in1 = angleBetweenPoints(Point2D(cz1, cx1), Point2D(pos.z, pos.x));
    double out1 = (gamma < 0) ? in1 + alpha1 : in1 - alpha1;
    convertTo2PI(out1);				// ???? ????? ?? 0...2PI
    // ??????? ???????? ? ?????
    double gm1 = atan((pos.v*pos.v) / (G*R));

    if(gamma > 0) omega1 = -omega1;
    double time1 = getManevrTime(in1, out1, omega1);	// ??????? ?????????? ??????? ?? ???????? ?? alpha1

    return ManeuverInfo(coordinate(cx1, pos.y, cz1), R, time1, in1, out1, omega1);
}


// ?????????? ????????
void buildManevrTrack(const LA& pos, const ManeuverInfo& minfo, vector<LA>& track) {
    double t(0), delta_t(1.0);

    double z0 = minfo.getCenter().z, x0 = minfo.getCenter().x;
    double R = minfo.getRadius(), omega = minfo.getAngularVelocity();
    double currentAngle = minfo.getInAngle();
    for(t; t < minfo.getNeedTime(); t += delta_t) {
        double zt(z0 + R*cos(currentAngle)), xt(x0 + R*sin(currentAngle));


        track.push_back(LA(t, xt, pos.y, zt, pos.v));
        currentAngle += omega;
    }
}


// ?????????? ?????????
void buildInterceptionTrack(const LA& our, InterceptionInfo info, vector<TrackPoint>& trajectory, int steps) {
    if(steps == -1 && !trajectory.empty()) trajectory.clear();

    double delta_t(1.0);
    double vz = our.v*cos(GPI2 - info.getCource()),
           vx = our.v*sin(GPI2 - info.getCource());
    double zt = our.z, xt = our.x;
    double time = (steps == -1) ? info.getTime() : std::min(info.getTime(), steps*delta_t);

    if(steps == -1 && trajectory.empty()) trajectory.push_back(TrackPoint(coordinate(our.x, our.y, our.z), 0.0));


    for(double t(0); t < time; t += delta_t) {
        zt += vz, xt += vx;
        trajectory.push_back(TrackPoint(coordinate(xt, our.y, zt), t));
    }

    double eps = ceil(time) - time;
    if(eps != 0) trajectory.push_back(TrackPoint(coordinate(xt+eps*vx, our.y, zt+eps*vz), time));
}
// ?????????? ?????????
void buildManevrTrack2(coordinate startPoint, ManeuverInfo minfo, vector<TrackPoint>& trajectory) {
    if(!trajectory.empty()) trajectory.clear();

    double delta_t(1.0);
    size_t size = ceil(minfo.getNeedTime()/ delta_t) + 1;
    trajectory.reserve(size);

    coordinate center = minfo.getCenter();
    double z0 = center.z, x0 = center.x;
    double R = minfo.getRadius(), omega = minfo.getAngularVelocity();
    double startAngle = minfo.getInAngle(), currentAngle = startAngle;

    trajectory.push_back(TrackPoint(startPoint, 0.0));
    for(double t(0.0 + delta_t); t < minfo.getNeedTime(); t += delta_t) {
        currentAngle += omega;
        double zc = z0 + R*cos(currentAngle),
               xc = x0 + R*sin(currentAngle);

        trajectory.push_back(TrackPoint(coordinate(xc, center.y, zc), t));
    }
}
// ?????????? ????????-????????
void buildTrack2(const LA& our, const ManeuverInfo& minfo, const InterceptionInfo& info, vector<TrackPoint>& track) {
    if(!track.empty()) track.clear();

    double time = minfo.getNeedTime() + info.time,
            delta_t(1.0), t(0.0);
    track.reserve(ceil(time/delta_t));

    // ?????????? ???????
    double z0 = minfo.getCenter().z, x0 = minfo.getCenter().x;
    double R = minfo.getRadius(), omega = minfo.getAngularVelocity();
    double currentAngle = minfo.getInAngle();
    for(t; t < minfo.getNeedTime(); t += delta_t) {
        double zt(z0 + R*cos(currentAngle)), xt(x0 + R*sin(currentAngle));
        track.push_back(TrackPoint(coordinate(xt, our.y, zt), t));
        currentAngle += omega;
    }

    // ?????????? ????????????? ?????????
    double vz = our.v*cos(GPI2 - info.getCource()),
           vx = our.v*sin(GPI2 - info.getCource());
    double zt, xt;
    if(!track.empty()) {
        zt = track.back().z;
        xt = track.back().x;
    }
    for(t; t < time; t += delta_t) {
        zt += vz, xt += vx;
        track.push_back(TrackPoint(coordinate(xt, our.y, zt), t));
    }

}
// ?????????? ??????
void buildPogonyaTrack(const LA& our, const LA& target, double time, vector<TrackPoint>& track, int steps) {
    //track.reserve(ceil(time));
    time = (steps == -1) ? time : steps;

    double zt1 = our.z, xt1 = our.x,
           zt2 = target.z, xt2 = target.x;
    double vz2 = target.v*cos(GPI2 - target.psi), vx2 = target.v*sin(GPI2 - target.psi);

    if(track.empty() && steps == -1) track.push_back(TrackPoint(coordinate(our.x, our.y, our.z), 0.0));
    for(double t(1.0); t < time; ++t) {
        zt2 += vz2, xt2 += vx2;
        double angle = angleBetweenPoints(Point2D(zt1, xt1), Point2D(zt2, xt2));
        zt1 += our.v*cos(angle), xt1 += our.v*sin(angle);
        track.push_back(TrackPoint(coordinate(xt1, our.y, zt1), track.size()));
    }
}
// ?????????? ???????
void buildTwoManeuvertrack(const LA& our, const LA& target, const TwoManeuverInfo& m2info, vector<TrackPoint>& track) {
    if(!track.empty()) track.clear();
    double t(0), delta_t(1.0);

    // ?????????? ??????? ???????
    double z0 = m2info.minfo1.getCenter().z, x0 = m2info.minfo1.getCenter().x;
    double R = m2info.minfo1.getRadius(), omega = m2info.minfo1.getAngularVelocity();
    double currentAngle = m2info.minfo1.getInAngle();
    for(t; t < m2info.minfo1.getNeedTime(); t += delta_t) {
        double zt(z0 + R*cos(currentAngle)), xt(x0 + R*sin(currentAngle));
        track.push_back(TrackPoint(coordinate(xt, our.y, zt), t));
        currentAngle += omega;
    }

    // ?????????? ?????????????? ??????? ?? ??????? ?????????
    // ????? ??????
    double zt, xt;
    //if(!track.empty()) { zt = track.back().z; xt = track.back().x; }
    //else zt = our.z; xt = our.x;
    zt = track.back().z; xt = track.back().x;

    // ????? ?????
    coordinate inputPoint2 = m2info.minfo2.getInPoint();	// ????? ????? ?? ?????? ????????
    double zend = inputPoint2.z, xend = inputPoint2.x;
    // ???????? ?????????? ?????????
    double vz = our.v*cos(GPI2 - m2info.kurs1),
           vx = our.v*sin(GPI2 - m2info.kurs1);

    int count = std::floor(m2info.lenght / our.v);
    for(int i = 0; i < count; i++, t += delta_t) {
        zt += vz, xt+= vx;
        track.push_back(TrackPoint(coordinate(xt, our.y, zt), t));
    }

    // ?????????? ??????? ???????
    z0 = m2info.minfo2.getCenter().z, x0 = m2info.minfo2.getCenter().x;
    R = m2info.minfo2.getRadius(), omega = m2info.minfo2.getAngularVelocity();
    currentAngle = m2info.minfo2.getInAngle();
    double t2 = 0;
    for(t2, t; t2 < m2info.minfo2.getNeedTime(); t2 += delta_t, t+= delta_t) {
        double zt(z0 + R*cos(currentAngle)), xt(x0 + R*sin(currentAngle));
        track.push_back(TrackPoint(coordinate(xt, our.y, zt), t));
        currentAngle += omega;
    }

    // ?????????? ?????????????? ??????? ?? ???? (???? ??????)


}

// ????????????? ?????????? ????
void buildTargetTrack(const LA& target, double time, vector<TrackPoint>& track) {
    double delta_t(1.0);
    double vz = target.v*cos(GPI2 - target.psi),
           vx = target.v*sin(GPI2 - target.psi);

    double zt = target.z, xt = target.x;
    track.push_back(TrackPoint(coordinate(xt, target.y, zt), 0));

    for(double t(delta_t); t < time; t += delta_t) {
        zt += vz, xt += vx;
        track.push_back(TrackPoint(coordinate(xt, target.y, zt), t));
    }

    //double eps = ceil(time) - time;
    //if(eps != 0) track.push_back(TrackPoint(coordinate(xt+eps*vx, target.y, zt+eps*vz), time));
}
